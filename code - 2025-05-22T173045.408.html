<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Orchid Instrument - FX Intensity V8</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        /* ... (All CSS styles remain identical to V7) ... */
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500&family=Playfair+Display:wght@700&family=Roboto:wght@300;400;700&display=swap');
        body { font-family: 'Roboto', sans-serif; background-color: #1a1a1a; color: #e0e0e0; margin: 0; padding: 10px 0; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; min-height: 100vh; overflow-x: hidden; -webkit-tap-highlight-color: transparent; }
        #user-instruction { font-family: 'Roboto Mono', monospace; font-size: 0.9em; margin-bottom: 10px; color: #bbb; cursor: pointer; text-align: center; padding: 0 10px; }
        #orchid-instrument { background-color: #2D2D2D; border: 1px solid #111; border-radius: 10px; padding: 10px; display: flex; flex-direction: column; align-items: center; box-shadow: 0px 3px 10px rgba(0,0,0,0.4), inset 0 0 3px rgba(0,0,0,0.2); width: 100%; max-width: 700px; position: relative; box-sizing: border-box; }
        .instrument-brand-top-left { display: none; } .instrument-brand-right { display: none; }
        .top-knob-row { display: flex; flex-wrap: wrap; justify-content: space-around; width: 100%; margin: 5px 0 10px 0; padding-bottom: 8px; border-bottom: 1px solid #404040; }
        .knob-group { display: flex; gap: 5px; margin-bottom: 5px; }
        .knob { display: flex; flex-direction: column; align-items: center; font-size: 0.5em; color: #A0A0A0; text-transform: uppercase; letter-spacing: 0.5px; width: 45px; text-align: center; }
        .knob input[type="range"] { -webkit-appearance: none; appearance: none; width: 26px; height: 26px; background: #383838; border-radius: 50%; border: 1px solid #202020; cursor: pointer; margin-bottom: 1px; padding: 0; box-shadow: inset 0 0 2px rgba(0,0,0,0.3); position: relative; }
        .knob input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 8px; height: 8px; background: #999; border-radius: 50%; cursor: pointer; margin-top: -3px; box-shadow: 0 0 1px rgba(0,0,0,0.5); }
        .knob input[type="range"]::-moz-range-thumb { width: 8px; height: 8px; background: #999; border-radius: 50%; cursor: pointer; border: none; box-shadow: 0 0 1px rgba(0,0,0,0.5); }
        .central-display { width: 100%; display: flex; flex-direction: column; align-items: center; margin-bottom: 10px; min-height: 60px; }
        #chord-name-output { font-family: 'Playfair Display', serif; font-size: 2.5em; color: #FFFFFF; margin-bottom: 5px; letter-spacing: 1px; min-height: 1.1em; }
        #note-visualizer { display: flex; height: 12px; background-color: #222; padding: 2px; border-radius: 2px; border: 1px solid #181818; }
        .visualizer-note-segment { width: 8px; height: 100%; margin: 0 1px; background-color: #404040; border-radius: 1px; }
        .visualizer-note-segment.active { background-color: #FF6B6B; box-shadow: 0 0 3px #FF6B6B; }
        .interaction-area { display: flex; flex-direction: column; width: 100%; align-items: center; gap: 10px; }
        .left-panel { display: flex; flex-direction: column; align-items: center; width: auto; }
        .chord-modifier-buttons { display: grid; grid-template-columns: repeat(4, 45px); grid-template-rows: repeat(2, 30px); gap: 5px; margin-bottom: 8px; }
        .chord-mod-btn { background-color: #484848; color: #C0C0C0; border: 1px solid #252525; border-radius: 3px; font-size: 0.7em; font-weight: 500; cursor: pointer; transition: background-color 0.1s, box-shadow 0.1s; display: flex; align-items: center; justify-content: center; box-shadow: 0 1px 1px rgba(0,0,0,0.3); }
        .chord-mod-btn:active { transform: translateY(1px); box-shadow: none; }
        .chord-mod-btn.active { background-color: #FF6B6B; color: #FFFFFF; box-shadow: 0 0 6px #FF6B6B, inset 0 0 2px rgba(255,255,255,0.2); }
        .large-knob-control { display: flex; flex-direction: column; align-items: center; margin-top: 5px; }
        .large-knob-label { font-size: 0.6em; color: #888; text-transform: uppercase; margin-bottom: 1px; }
        #knob-voicing { -webkit-appearance: none; appearance: none; width: 50px; height: 50px; background: #383838; border-radius: 50%; border: 1px solid #202020; cursor: pointer; margin-bottom: 2px; padding: 0; box-shadow: inset 0 0 3px rgba(0,0,0,0.4); position: relative; }
        #knob-voicing::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 16px; height: 16px; background: #999; border-radius: 50%; cursor: pointer; margin-top: -7px; }
        #knob-voicing::-moz-range-thumb { width: 16px; height: 16px; background: #999; border-radius: 50%; cursor: pointer; border: none; }
        .bass-button-container { display: flex; flex-direction: column; align-items: center; margin-top: 8px; }
        #bass-toggle-btn { width: 20px; height: 20px; background-color: #484848; border: 1px solid #252525; border-radius: 50%; cursor: pointer; box-shadow: 0 1px 1px rgba(0,0,0,0.3); transition: background-color 0.1s, box-shadow 0.1s; }
        #bass-toggle-btn:active { transform: translateY(1px); box-shadow: none; }
        #bass-toggle-btn.active { background-color: #FF6B6B; box-shadow: 0 0 5px #FF6B6B, inset 0 0 2px rgba(255,255,255,0.2); }
        .bass-button-label { font-size: 0.55em; color: #888; text-transform: uppercase; margin-top: 2px; }
        .keyboard-area-container { display: flex; flex-direction: column; align-items: center; width: 100%; }
        #keyboard { display: flex; position: relative; background-color: #1C1C1C; padding: 5px; border-radius: 4px; box-shadow: inset 0 1px 3px rgba(0,0,0,0.4); height: 90px; align-items: flex-start; width: calc(100% - 10px); max-width: 420px; overflow-x: auto; -webkit-overflow-scrolling: touch; }
        .key { border: 1px solid #151515; border-radius: 0 0 3px 3px; box-sizing: border-box; cursor: pointer; user-select: none; transition: background-color 0.05s; flex-shrink: 0; }
        .key.white { width: 26px; height: 80px; background-color: #E8E8E8; margin-right: 1px; box-shadow: 0px 1px 1px rgba(0,0,0,0.2); }
        .key.white:active { background-color: #ccc; }
        .key.white.active { background-color: #FF8C8C; box-shadow: inset 0 0 3px rgba(0,0,0,0.2); }
        .key.black { width: 16px; height: 50px; background-color: #303030; color: #f0f0f0; position: absolute; z-index: 1; box-shadow: 0px 1px 1px rgba(0,0,0,0.4); }
        .key.black:active { background-color: #222; }
        .key.black.active { background-color: #D15050; box-shadow: inset 0 0 3px rgba(0,0,0,0.3); }
        .octave-controls { display: flex; gap: 8px; margin-top: 8px; }
        .octave-btn { background-color: #484848; color: #C0C0C0; border: 1px solid #252525; border-radius: 3px; font-size: 0.7em; padding: 4px 8px; cursor: pointer; user-select: none; }
        .octave-btn:active { transform: translateY(1px); }
        #octave-display { color: #C0C0C0; font-size: 0.8em; padding: 4px; min-width: 18px; text-align: center; }
    </style>
</head>
<body>
    <div id="user-instruction">Click here to enable audio. Then, tap keys and buttons to play.</div>

    <div id="orchid-instrument">
        <div class="top-knob-row">
            <div class="knob-group">
                <div class="knob"><input type="range" id="knob-sound" min="0" max="3" value="0" step="1" title="Sound"><label for="knob-sound">Sound</label></div>
                <div class="knob"><input type="range" id="knob-fx-select" min="0" max="4" value="0" step="1" title="Select Effect Type"><label id="label-fx" for="knob-fx-select">FX: Off</label></div> <!-- Renamed from knob-fx -->
                <div class="knob"><input type="range" id="knob-fx-intensity" min="0" max="100" value="50" step="1" title="FX Intensity/Wet"><label for="knob-fx-intensity">FX Amount</label></div> <!-- New Intensity Knob -->
                <div class="knob"><input type="range" id="knob-key-transpose" min="-12" max="12" value="0" step="1" title="Transpose"><label for="knob-key-transpose">Key</label></div>
            </div>
            <div class="knob-group">
                <div class="knob"><input type="range" id="knob-bass-vol" min="0" max="100" value="0" step="1" title="Sub Bass Vol"><label for="knob-bass-vol">SubBass</label></div>
                <div class="knob"><input type="range" id="knob-loop" min="0" max="3" value="0" step="1" title="Arp Mode"><label for="knob-loop">Arp</label></div>
                <div class="knob"><input type="range" id="knob-bpm" min="40" max="240" value="120" step="1" title="Arp BPM"><label for="knob-bpm">BPM</label></div>
                <div class="knob"><input type="range" id="knob-volume" min="0" max="100" value="75" step="1" title="Volume"><label for="knob-volume">Volume</label></div>
            </div>
        </div>
        <div class="central-display">
            <div id="chord-name-output">---</div>
            <div id="note-visualizer"></div>
        </div>
        <div class="interaction-area">
            <div class="left-panel">
                <div class="chord-modifier-buttons">
                    <button class="chord-mod-btn" data-type="Dim">Dim</button>
                    <button class="chord-mod-btn" data-type="Min">Min</button>
                    <button class="chord-mod-btn active" data-type="Maj">Maj</button>
                    <button class="chord-mod-btn" data-type="Sus">Sus</button>
                    <button class="chord-mod-btn" data-type="6">6</button>
                    <button class="chord-mod-btn" data-type="m7">m⁷</button>
                    <button class="chord-mod-btn" data-type="M7">M⁷</button>
                    <button class="chord-mod-btn" data-type="9">9</button>
                </div>
                <div class="large-knob-control">
                    <label for="knob-voicing" id="label-voicing" class="large-knob-label">Voicing</label>
                    <input type="range" id="knob-voicing" min="0" max="2" value="0" step="1" title="Chord Inversion or LFO Rate">
                    <div class="bass-button-container">
                        <button id="bass-toggle-btn"></button>
                        <div class="bass-button-label">ChordBass</div>
                    </div>
                </div>
            </div>
            <div class="keyboard-area-container">
                <div id="keyboard"></div>
                <div class="octave-controls">
                    <button class="octave-btn" id="octave-down" title="Octave Down">-</button>
                    <span id="octave-display">0</span>
                    <button class="octave-btn" id="octave-up" title="Octave Up">+</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const NOTE_NAMES_SHARP = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const NOTE_NAMES_FLAT =  ['C', 'D♭', 'D', 'E♭', 'E', 'F', 'G♭', 'G', 'A♭', 'A', 'B♭', 'B'];
            const OSC_TYPES = ['fatsawtooth', 'sine', 'square', 'triangle'];
            const ARP_PATTERNS = ['off', 'up', 'down', 'upDown'];
            const FX_TYPES = ['off', 'reverb', 'vibrato', 'filter', 'tremolo']; // Effect types
            const VOICING_INVERSIONS = ['root', 'firstInv', 'secondInv'];
            const DEFAULT_ENV_RELEASE = 0.4;

            const KEYBOARD_MAP = [ /* ... (same) ... */ { midi: 48, name: 'C', type: 'white' }, { midi: 49, name: 'C#', type: 'black' },{ midi: 50, name: 'D', type: 'white' }, { midi: 51, name: 'D#', type: 'black' },{ midi: 52, name: 'E', type: 'white' }, { midi: 53, name: 'F', type: 'white' },{ midi: 54, name: 'F#', type: 'black' }, { midi: 55, name: 'G', type: 'white' },{ midi: 56, name: 'G#', type: 'black' }, { midi: 57, name: 'A', type: 'white' },{ midi: 58, name: 'A#', type: 'black' }, { midi: 59, name: 'B', type: 'white' },{ midi: 60, name: 'C', type: 'white' }, { midi: 61, name: 'C#', type: 'black' },{ midi: 62, name: 'D', type: 'white' }, { midi: 63, name: 'D#', type: 'black' },{ midi: 64, name: 'E', type: 'white' }];
            const NUM_VISUALIZER_SEGMENTS = 12;

            let synth, reverb, subOsc, filter, lfo, arp, masterGain;
            let currentRootNoteMidi = null, currentRootNoteName = '';
            let keyboardOctaveOffset = 0, currentKeyTranspose = 0;
            let selectedTriadQuality = 'Maj';
            const selectedExtensions = { '6': false, 'm7': false, 'M7': false, '9': false };
            let addBassNoteActive = false;
            let activeSynthNotes = [], currentArpNotes = [];
            let isPlaying = false, audioInitialized = false;

            const ui = {
                instruction: document.getElementById('user-instruction'), chordName: document.getElementById('chord-name-output'), noteVisualizer: document.getElementById('note-visualizer'), keyboard: document.getElementById('keyboard'), chordModifiers: document.querySelectorAll('.chord-mod-btn'), bassToggle: document.getElementById('bass-toggle-btn'), octaveDown: document.getElementById('octave-down'), octaveUp: document.getElementById('octave-up'), octaveDisplay: document.getElementById('octave-display'),
                knobs: { 
                    sound: document.getElementById('knob-sound'), 
                    fxSelect: document.getElementById('knob-fx-select'), // Renamed
                    fxIntensity: document.getElementById('knob-fx-intensity'), // New
                    keyTranspose: document.getElementById('knob-key-transpose'), 
                    bassVol: document.getElementById('knob-bass-vol'), 
                    loop: document.getElementById('knob-loop'), 
                    bpm: document.getElementById('knob-bpm'), 
                    volume: document.getElementById('knob-volume'), 
                    voicing: document.getElementById('knob-voicing')
                },
                labels: { fx: document.getElementById('label-fx'), voicing: document.getElementById('label-voicing') }
            };
            // Element check (ensure all new/renamed elements are included)
            let allElementsExist = Object.values(ui).every(el=>el) && ui.chordModifiers.length === 8 && Object.values(ui.knobs).every(k=>k) && Object.values(ui.labels).every(l=>l);
            if (!allElementsExist) { console.error("Essential UI element not found."); if(ui.instruction) ui.instruction.textContent = "Error: UI elements missing."; return; }
            
            ui.instruction.addEventListener('click', initializeAudioAndSynth);

            async function initializeAudioAndSynth() { /* ... (same) ... */ if (audioInitialized) { if (!synth) createSynthAndEffects(); return; } try { await Tone.start(); audioInitialized = true; createSynthAndEffects(); if (ui.instruction) ui.instruction.textContent = "Audio Initialized."; } catch (e) { console.error("Error Tone.start:", e); if (ui.instruction) ui.instruction.textContent = "Audio Error."; } }

            function createSynthAndEffects() {
                [synth, reverb, subOsc, filter, lfo, arp, masterGain].forEach(node => node && node.dispose());
                masterGain = new Tone.Gain(0.75).toDestination();
                reverb = new Tone.Reverb({ decay: 1.5, wet: 0 }).connect(masterGain);
                filter = new Tone.Filter(20000, "lowpass").connect(reverb);
                synth = new Tone.PolySynth(Tone.Synth, {
                    envelope: { attack: 0.02, decay: 0.1, sustain: 0.8, release: DEFAULT_ENV_RELEASE }
                }).connect(filter);
                subOsc = new Tone.Oscillator({ type: 'sine', frequency: 220, volume: -Infinity }).connect(filter);
                subOsc.start();
                lfo = new Tone.LFO({frequency: getLfoRateFromVoicingKnob(), min: 0, max: 1, amplitude: 0}).start();
                arp = new Tone.Pattern((time, note) => {
                    synth.triggerAttackRelease(note, "8n", time);
                }, [], ARP_PATTERNS[parseInt(ui.knobs.loop.value)] || "up");
                arp.interval = "8n";
                applyAllKnobSettings();
            }

            function applyAllKnobSettings(){
                applyOscillatorType(); applyMasterGainSetting(); applyFxSettings(); 
                applySubOscVolume(); applyBPM(); updateVoicingKnobLabel();
            }

            function getEffectiveRootMidi() { /* ... (same) ... */ return currentRootNoteMidi === null ? null : currentRootNoteMidi + keyboardOctaveOffset + currentKeyTranspose; }
            
            function applyVoicingToNotes(notes) {
                if (!notes || notes.length < 3) return notes;
                const currentFxType = FX_TYPES[parseInt(ui.knobs.fxSelect.value)];
                // Voicing knob controls LFO rate if an LFO effect is active
                if (currentFxType === 'vibrato' || currentFxType === 'filter' || currentFxType === 'tremolo') return notes;
                
                const voicingIndex = parseInt(ui.knobs.voicing.value); 
                const voicingType = VOICING_INVERSIONS[voicingIndex]; 
                let voicedNotes = [...notes];
                switch (voicingType) { case 'firstInv': voicedNotes[0] += 12; voicedNotes.sort((a, b) => a - b); break; case 'secondInv': voicedNotes[0] += 12; if (voicedNotes.length > 1) voicedNotes[1] += 12; voicedNotes.sort((a, b) => a - b); break; }
                return voicedNotes;
            }

            function buildChordNotesMidi() { /* ... (same) ... */ 
                const effectiveRoot = getEffectiveRootMidi(); if (effectiveRoot === null) return [];
                let notes = []; let baseTriadMidi = [];
                switch (selectedTriadQuality) { case 'Maj': baseTriadMidi = [0, 4, 7]; break; case 'Min': baseTriadMidi = [0, 3, 7]; break; case 'Dim': baseTriadMidi = [0, 3, 6]; break; case 'Sus': baseTriadMidi = [0, 5, 7]; break; }
                notes.push(...baseTriadMidi.map(interval => effectiveRoot + interval));
                if (selectedExtensions['6']) notes.push(effectiveRoot + 9); if (selectedExtensions['m7']) notes.push(effectiveRoot + 10); if (selectedExtensions['M7']) notes.push(effectiveRoot + 11); if (selectedExtensions['9']) notes.push(effectiveRoot + 14);
                let finalNotes = [...new Set(notes)].sort((a, b) => a - b);
                finalNotes = applyVoicingToNotes(finalNotes);
                if (addBassNoteActive && ARP_PATTERNS[parseInt(ui.knobs.loop.value)] === 'off') { finalNotes.unshift(effectiveRoot - 12); finalNotes = [...new Set(finalNotes)].sort((a,b) => a-b); }
                return finalNotes;
            }
            
            function midiToNoteNameWithOctave(midiNote) { /* ... (same) ... */ return NOTE_NAMES_SHARP[midiNote % 12] + (Math.floor(midiNote / 12) - 1); }
            function getRootDisplayNameForOutput(rootMidi) { /* ... (same) ... */ return rootMidi === null ? (currentRootNoteName || '') : (NOTE_NAMES_FLAT[rootMidi % 12].includes('♭') ? NOTE_NAMES_FLAT[rootMidi % 12] : NOTE_NAMES_SHARP[rootMidi % 12]); }
            function getChordDisplayNameText() { /* ... (same) ... */  if (currentRootNoteMidi === null) return "---"; const e = getEffectiveRootMidi(); let n = getRootDisplayNameForOutput(e); let q = "", x = ""; if (selectedTriadQuality === 'Min') q = 'm'; else if (selectedTriadQuality === 'Dim') q = 'dim'; else if (selectedTriadQuality === 'Sus') q = 'sus'; if (selectedExtensions['M7']) x += 'M7'; else if (selectedExtensions['m7']) x += '7'; if (selectedExtensions['9']) { if (x === 'M7') x = 'maj9'; else if (x === '7') x = '9'; else if (!x && selectedTriadQuality === 'Maj') x = 'add9'; else x = (q && !x ? '' : x) + '9';} if (selectedExtensions['6']) { if (!x.includes('7') && !x.includes('9')) x += '6';} if (selectedTriadQuality === 'Maj' && (x.startsWith('M') || x.startsWith('maj') || x.startsWith('add') || x.match(/^[0-9]/) )) n += x; else n += q + x; if (n === getRootDisplayNameForOutput(e) && selectedTriadQuality === 'Maj' && Object.values(selectedExtensions).every(v => !v)) {} else if (n === getRootDisplayNameForOutput(e) + "m" && selectedTriadQuality === 'Min' && Object.values(selectedExtensions).every(v => !v)){} return n; }
            function updateVisuals() { /* ... (same, calls updateFxKnobLabel, updateVoicingKnobLabel) ... */ ui.chordName.textContent = getChordDisplayNameText(); const c = buildChordNotesMidi(); const nc = new Array(NUM_VISUALIZER_SEGMENTS).fill(false); c.forEach(m => { nc[m % 12] = true; }); ui.noteVisualizer.childNodes.forEach((s, i) => s.classList.toggle('active', nc[i])); ui.chordModifiers.forEach(b => { const t = b.dataset.type; const iT = ['Dim', 'Min', 'Maj', 'Sus'].includes(t); if (iT) b.classList.toggle('active', selectedTriadQuality === t); else b.classList.toggle('active', !!selectedExtensions[t]); }); ui.bassToggle.classList.toggle('active', addBassNoteActive); document.querySelectorAll('#keyboard .key.active').forEach(k => k.classList.remove('active')); if (currentRootNoteMidi !== null && isPlaying) { const aK = Array.from(ui.keyboard.children).find(k => parseInt(k.dataset.midi) === currentRootNoteMidi); if (aK) aK.classList.add('active'); } ui.octaveDisplay.textContent = keyboardOctaveOffset / 12; updateFxKnobLabel(); updateVoicingKnobLabel(); }

            async function handlePlayTrigger() {
                await initializeAudioAndSynth();
                if (!synth || !audioInitialized || currentRootNoteMidi === null) {
                    releaseCurrentSound(true); updateVisuals(); return;
                }
                releaseCurrentSound(false); 
                
                const currentArpPattern = ARP_PATTERNS[parseInt(ui.knobs.loop.value)];
                currentArpNotes = buildChordNotesMidi().map(note => midiToNoteNameWithOctave(note));

                if (currentArpPattern !== 'off' && currentArpNotes.length > 0) {
                    arp.values = currentArpNotes; arp.pattern = currentArpPattern;
                    if (Tone.Transport.state !== "started") Tone.Transport.start();
                    arp.start(0); isPlaying = true;
                } else if (currentArpNotes.length > 0) {
                    activeSynthNotes = currentArpNotes;
                    synth.triggerAttack(activeSynthNotes, Tone.now()); isPlaying = true;
                } else { isPlaying = false; }

                if (subOsc && parseFloat(ui.knobs.bassVol.value) > 0 && getEffectiveRootMidi() !== null) { applySubOscVolume(); } 
                else if (subOsc) { subOsc.volume.linearRampToValueAtTime(-Infinity, Tone.now() + 0.01); }
                updateVisuals();
            }

            function releaseCurrentSound(clearRoot = true) {
                if (arp && arp.state === "started") { arp.stop(0); arp.cancel(); arp.values = []; }
                if (synth && (activeSynthNotes.length > 0 || (isPlaying && arp.state === "stopped")) ) { // Ensure releaseAll is called if something was playing via synth directly
                    synth.releaseAll(Tone.now()); activeSynthNotes = []; 
                }
                if (subOsc) { subOsc.volume.linearRampToValueAtTime(-Infinity, Tone.now() + 0.01); }
                
                isPlaying = false;
                if (clearRoot) { currentRootNoteMidi = null; currentRootNoteName = ''; }
                updateVisuals();
            }

            function createVisualKeyboard() { /* ... (same with touchstart) ... */
                 let whiteKeyOffsetPx = 0; const whiteKeyWidth = 26; const whiteKeyMargin = 1; const blackKeyWidth = 16;
                KEYBOARD_MAP.forEach(keyInfo => {
                    const keyEl = document.createElement('div'); keyEl.classList.add('key', keyInfo.type); keyEl.dataset.midi = keyInfo.midi; keyEl.dataset.noteName = keyInfo.name;
                    if (keyInfo.type === 'white') { keyEl.style.left = `${whiteKeyOffsetPx}px`; whiteKeyOffsetPx += whiteKeyWidth + whiteKeyMargin; } else { keyEl.style.left = `${whiteKeyOffsetPx - (whiteKeyWidth + whiteKeyMargin) + whiteKeyWidth - (blackKeyWidth/2) + (whiteKeyMargin/2)}px`; }
                    const handleKeyPress = async (e) => { e.preventDefault(); const newRootMidi = parseInt(keyEl.dataset.midi); if (isPlaying && newRootMidi === currentRootNoteMidi) { releaseCurrentSound(true); } else { currentRootNoteMidi = newRootMidi; currentRootNoteName = keyEl.dataset.noteName; handlePlayTrigger(); }};
                    keyEl.addEventListener('mousedown', handleKeyPress); keyEl.addEventListener('touchstart', handleKeyPress, {passive: false});
                    ui.keyboard.appendChild(keyEl);
                });
            }
            function createNoteVisualizer() { /* ... (same) ... */ ui.noteVisualizer.innerHTML = ''; for (let i = 0; i < NUM_VISUALIZER_SEGMENTS; i++) { const segment = document.createElement('div'); segment.classList.add('visualizer-note-segment'); ui.noteVisualizer.appendChild(segment); } }
            ui.chordModifiers.forEach(button => button.addEventListener('click', async () => { const type = button.dataset.type; const isTriad = ['Dim', 'Min', 'Maj', 'Sus'].includes(type); if (isTriad) selectedTriadQuality = type; else selectedExtensions[type] = !selectedExtensions[type]; if (isPlaying) handlePlayTrigger(); else updateVisuals(); }));
            ui.bassToggle.addEventListener('click', async () => { addBassNoteActive = !addBassNoteActive; if (isPlaying && ARP_PATTERNS[parseInt(ui.knobs.loop.value)] === 'off') handlePlayTrigger(); else updateVisuals(); });
            ui.octaveDown.addEventListener('click', () => { keyboardOctaveOffset -= 12; if (keyboardOctaveOffset < -24) keyboardOctaveOffset = -24; if (isPlaying) handlePlayTrigger(); else updateVisuals(); });
            ui.octaveUp.addEventListener('click', () => { keyboardOctaveOffset += 12; if (keyboardOctaveOffset > 24) keyboardOctaveOffset = 24; if (isPlaying) handlePlayTrigger(); else updateVisuals(); });

            // --- Knob Apply Functions & Listeners ---
            function applyOscillatorType() { 
                if (synth) {
                    synth.set({ oscillator: { type: OSC_TYPES[parseInt(ui.knobs.sound.value)] || 'fatsawtooth' } }); 
                    const currentFx = FX_TYPES[parseInt(ui.knobs.fxSelect.value)];
                    if (currentFx === 'vibrato') applyFxSettings(); // Re-apply LFO if vibrato is active
                }
            }
            ui.knobs.sound.addEventListener('input', applyOscillatorType);
            
            function updateFxKnobLabel() {
                const fxType = FX_TYPES[parseInt(ui.knobs.fxSelect.value)];
                let labelText = "FX: ";
                switch(fxType) {
                    case 'reverb': labelText += "Reverb"; break;
                    case 'vibrato': labelText += "Vibrato"; break;
                    case 'filter': labelText += "Filter"; break;
                    case 'tremolo': labelText += "Tremolo"; break;
                    default: labelText += "Off"; break;
                }
                ui.labels.fx.textContent = labelText;
            }

            function applyFxSettings() {
                if (!audioInitialized || !lfo || !synth || !filter || !masterGain || !reverb) return;
                
                const fxType = FX_TYPES[parseInt(ui.knobs.fxSelect.value)];
                const intensity = parseFloat(ui.knobs.fxIntensity.value) / 100; // 0-1

                // Reverb always set based on its selection & intensity knob
                reverb.wet.value = (fxType === 'reverb') ? intensity : 0;

                // LFO Reset and Setup
                lfo.amplitude.value = 0; lfo.disconnect();
                if (synth.voices) synth.voices.forEach(voice => { if (voice.detune && voice.detune.isSignal) lfo.disconnect(voice.detune); });
                if (filter.frequency && filter.frequency.isSignal) lfo.disconnect(filter.frequency);
                if (masterGain.gain && masterGain.gain.isSignal) lfo.disconnect(masterGain.gain);

                if (fxType !== 'off' && fxType !== 'reverb') { // LFO-based effects
                    lfo.frequency.value = getLfoRateFromVoicingKnob();
                    lfo.amplitude.value = intensity; // Use intensity knob for LFO depth

                    switch (fxType) {
                        case 'vibrato':
                            lfo.min = -40; lfo.max = 40; // Cents
                            if (synth.voices) synth.voices.forEach(voice => { try { lfo.connect(voice.detune); } catch(e){/*ignore if voice not ready*/} });
                            break;
                        case 'filter':
                            lfo.min = filter.frequency.minValue || 150;
                            lfo.max = (filter.frequency.maxValue || 8000) * 0.8; 
                            if (filter.frequency.isSignal) lfo.connect(filter.frequency);
                            break;
                        case 'tremolo':
                            lfo.min = 1 - intensity; // Modulate gain from (1-depth)
                            lfo.max = 1;             // up to 1 (original volume)
                            // LFO amplitude for tremolo should be the 'intensity'
                            if (masterGain.gain.isSignal) lfo.connect(masterGain.gain);
                            break;
                    }
                }
                updateVoicingKnobLabel(); updateFxKnobLabel();
            }
            ui.knobs.fxSelect.addEventListener('input', applyFxSettings);
            ui.knobs.fxIntensity.addEventListener('input', applyFxSettings); // Intensity also triggers update
            
            ui.knobs.keyTranspose.addEventListener('input', () => { currentKeyTranspose = parseInt(ui.knobs.keyTranspose.value); if (isPlaying) handlePlayTrigger(); else updateVisuals(); });
            function applySubOscVolume() { /* ... (same) ... */ if (subOsc) { const volPercent = parseFloat(ui.knobs.bassVol.value); const effectiveRoot = getEffectiveRootMidi(); if (volPercent > 0 && effectiveRoot !== null) { const dbValue = Tone.gainToDb(volPercent / 100 * 0.5) -12; subOsc.volume.linearRampToValueAtTime(dbValue, Tone.now() + 0.05); const subFreq = Tone.Frequency(effectiveRoot - 12, "midi").toFrequency(); subOsc.frequency.setValueAtTime(subFreq, Tone.now()); } else { subOsc.volume.linearRampToValueAtTime(-Infinity, Tone.now() + 0.01); } } }
            ui.knobs.bassVol.addEventListener('input', applySubOscVolume);
            function applyMasterGainSetting() { /* ... (same) ... */ if (masterGain) { const volPercent = parseFloat(ui.knobs.volume.value); if (volPercent === 0) masterGain.gain.value = 0; else masterGain.gain.value = Math.pow(volPercent / 100, 2); } }
            ui.knobs.volume.addEventListener('input', applyMasterGainSetting);
            function applyBPM() { /* ... (same) ... */ if (audioInitialized) Tone.Transport.bpm.value = parseFloat(ui.knobs.bpm.value); }
            ui.knobs.bpm.addEventListener('input', applyBPM);
            ui.knobs.loop.addEventListener('input', () => { if (currentRootNoteMidi !== null) { handlePlayTrigger(); } else { releaseCurrentSound(true); updateVisuals(); } });
            
            function getLfoRateFromVoicingKnob() { /* ... (same) ... */ const rateValue = parseInt(ui.knobs.voicing.value); const lfoRates = [0.5, 2, 8]; return lfoRates[Math.min(rateValue, lfoRates.length - 1)] || 2; }
            function updateVoicingKnobLabel() { /* ... (same) ... */ const currentFx = FX_TYPES[parseInt(ui.knobs.fxSelect.value)]; ui.labels.voicing.textContent = (currentFx !== 'off' && currentFx !== 'reverb') ? "LFO Rate" : "Voicing"; }

            ui.knobs.voicing.addEventListener('input', () => {
                const currentFx = FX_TYPES[parseInt(ui.knobs.fxSelect.value)];
                if (currentFx !== 'off' && currentFx !== 'reverb' && lfo) {
                    lfo.frequency.value = getLfoRateFromVoicingKnob();
                } else { 
                    if (isPlaying) handlePlayTrigger(); else updateVisuals();
                }
            });

            createVisualKeyboard(); createNoteVisualizer(); updateVisuals(); 
            initializeAudioAndSynth();
        });
    </script>
</body>
</html>